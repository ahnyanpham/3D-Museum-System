<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <title>3D House</title>

    <link rel="stylesheet" href="https://js.arcgis.com/4.34/esri/themes/light/main.css" />
    <script src="https://js.arcgis.com/4.34/"></script>

    <style>
      html, body, #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }
    </style>

    <script>
      require([
        "esri/Map",
        "esri/views/SceneView",
        "esri/layers/GraphicsLayer",
        "esri/Graphic",
        "esri/geometry/Polygon",
        "esri/geometry/Point",
        "esri/symbols/PolygonSymbol3D",
        "esri/symbols/ExtrudeSymbol3DLayer",
        "esri/symbols/ObjectSymbol3DLayer",
		"esri/widgets/Search",
		"esri/geometry/geometryEngine",
		"esri/geometry/Polyline",
		"esri/geometry/Mesh"
      ], function(
        Map, SceneView, GraphicsLayer, Graphic, Polygon, Point,
        PolygonSymbol3D, ExtrudeSymbol3DLayer, ObjectSymbol3DLayer, Search, geometryEngine, Polyline, Mesh
      ) {

        // LAYER
        const layer = new GraphicsLayer();
		const mainCorlor = '#fbc2aa';

        const map = new Map({
          basemap: "topo",
          ground: "world-elevation",
          layers:[layer]
        });


        const view = new SceneView({
          container: "viewDiv",
          map: map,
          camera: {
				x: 106.70701,
				y: 10.76826,
				z: 50
			},
			tilt: 70
        });

//------------------------------------
        // L·∫ÆNG NGHE S·ª∞ KI·ªÜN CLICK V√Ä L·∫§Y T·ªåA ƒê·ªò
        // ------------------------------------
       view.on("click", function(event) {
    const screenPoint = event.screenPoint;

    // G·ªçi view.toMap() ƒë·ªìng b·ªô, kh√¥ng d√πng .then()
    const mapPoint = view.toMap(screenPoint);

    if (mapPoint) {
        const longitude = mapPoint.longitude;
        const latitude = mapPoint.latitude;
        const altitude = mapPoint.z;

        console.log("------------------------------------");
        console.log("T·ªça ƒë·ªô b·∫£n ƒë·ªì (Long, Lat, Z):", longitude.toFixed(5), latitude.toFixed(5), altitude);
        console.log("------------------------------------");
        
        // T√πy ch·ªçn: Th√™m m·ªôt Graphic (ƒëi·ªÉm) t·∫°i v·ªã tr√≠ ƒë√≥
        //addPointGraphic(mapPoint);
    }
});

        // T√πy ch·ªçn: H√†m ƒë·ªÉ v·∫Ω ƒëi·ªÉm
        /*function addPointGraphic(mapPoint) {
            layer.removeAll(); // X√≥a ƒëi·ªÉm c≈© (t√πy ch·ªçn)

            const pointSymbol = {
                type: "point-3d",
                symbolLayers: [{
                    type: "object",
                    width: 5, // Chi·ªÅu r·ªông 5m
                    height: 5, // Chi·ªÅu cao 5m
                    depth: 5, // Chi·ªÅu s√¢u 5m
                    resource: { primitive: "sphere" },
                    material: { color: "yellow" }
                }]
            };

            const pointGraphic = new Graphic({
                geometry: mapPoint,
                symbol: pointSymbol
            });

            layer.add(pointGraphic);
        }*/
// --------------------------
        // TH√äM SEARCH WIDGET
        // --------------------------
        const searchWidget = new Search({
            view: view,
            // (T√πy ch·ªçn) Thi·∫øt l·∫≠p provider n·∫øu b·∫°n mu·ªën t√πy ch·ªânh ngu·ªìn t√¨m ki·∫øm
            // V√≠ d·ª•: ch·ªâ t√¨m ki·∫øm trong layer c·ªßa b·∫°n, ho·∫∑c ch·ªâ d√πng 1 geocoder c·ª• th·ªÉ
        });

        // Th√™m widget v√†o g√≥c tr√™n b√™n ph·∫£i c·ªßa view
        view.ui.add(searchWidget, {
            position: "top-right" 
        });
		function distance3D(p1, p2) {
		  const dx = p2[0] - p1[0];
		  const dy = p2[1] - p1[1];
		  const dz = p2[2] - p1[2];
		  return Math.sqrt(dx*dx + dy*dy + dz*dz);
		}

		// T√¨m ƒëi·ªÉm P n·∫±m tr√™n AB, bi·∫øt ƒë·ªô d√†i AP, v√† ab.heigh
		function pointAtDistance(A, B, AP, abHeigh) {
		  const AB = distance3D(A, B);
		  const t = AP / AB;

		  return [
			A[0] + t * (B[0] - A[0]),
			A[1] + t * (B[1] - A[1]),
			(A[2] + t * (B[2] - A[2])) + abHeigh
		  ];
		}
		
		// H√†m tr·ª´ vector
		function sub(a, b) {
			return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
		}

		// H√†m c·ªông vector
		function add(a, b) {
			return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
		}

		// Nh√¢n vector v·ªõi s·ªë
		function scale(a, s) {
			return [a[0] * s, a[1] * s, a[2] * s];
		}

		// T√≠ch v√¥ h∆∞·ªõng
		function dot(a, b) {
			return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
		}

		// T√≠ch c√≥ h∆∞·ªõng
		function cross(a, b) {
			return [
				a[1]*b[2] - a[2]*b[1],
				a[2]*b[0] - a[0]*b[2],
				a[0]*b[1] - a[1]*b[0]
			];
		}

		// Chu·∫©n ho√° vector
		function normalize(v) {
			const len = Math.sqrt(dot(v, v));
			return scale(v, 1 / len);
		}

		function drawPolygon3D(pts, corlor) {
			const rect = new Polygon({
			  spatialReference: { wkid: 4326 },
			  rings: pts
			});

			const graphic = new Graphic({
			  geometry: rect,
			  symbol: {
				type: "polygon-3d",
				symbolLayers: [{
				  type: "fill",
				  material: { color: corlor }
				}]
			  }
			});
			view.graphics.add(graphic);
		}
		
		
		
		function drawColumn(A, B, C, colWidth, columnDistance, i, floorHeigh, isLastCol) {
			let length = colWidth;
			let width = colWidth;
			let bandLength = width + width/8;
			let bandWidth = width + width/8;
			let distanceFromFirstPoint = 0;
			if(i == 0) {
				length = 2*width;
				bandLength = length + width/8;
			} else {
				distanceFromFirstPoint += 2*width + columnDistance*(i) + width*(i-1);
			}
			let columnPoint1 = pointAtDistance(A, B, distanceFromFirstPoint, floorHeigh);
			let columnPoint2 = pointAtDistance(A, B, distanceFromFirstPoint + length, floorHeigh);
			let columnPoint3 = findC(A, columnPoint2, C, width);
			let columnPoint4 = findC(A, columnPoint1, C, width);
			let circleStartPoint = pointAtDistance(A, B, distanceFromFirstPoint + length + columnDistance, floorHeigh);
			let circleEndPoint = findC(A, circleStartPoint, C, width);
			let columnWidthAsMetter = distanceToMetter(columnPoint2, columnPoint3)/2;
			let R = distanceToMetter(columnPoint2, circleStartPoint)/2;
			let circleFloorDistance = 5 - R -  columnWidthAsMetter;
			let whiteBandHeight = 3;
			let whiteBandPoint1Temp = findC(columnPoint3, columnPoint4, columnPoint1, bandWidth);
			let whiteBandPoint2Temp = findC(columnPoint4, columnPoint3, columnPoint2, bandWidth);
			let whiteBandPoint3Temp = findC(columnPoint1, columnPoint2, columnPoint3, bandWidth);
			let whiteBandPoint4Temp = findC(columnPoint2, columnPoint1, columnPoint4, bandWidth);
			
			let whiteBandPoint1 = pointAtDistance(whiteBandPoint2Temp, whiteBandPoint1Temp, bandLength, whiteBandHeight);
			let whiteBandPoint2 = pointAtDistance(whiteBandPoint1Temp, whiteBandPoint2Temp, bandLength, whiteBandHeight);
			let whiteBandPoint3 = pointAtDistance(whiteBandPoint4Temp, whiteBandPoint3Temp, bandLength, whiteBandHeight);
			let whiteBandPoint4 = pointAtDistance(whiteBandPoint3Temp, whiteBandPoint4Temp, bandLength, whiteBandHeight);
			
			addExtrudedBox([whiteBandPoint1, whiteBandPoint2, whiteBandPoint3, whiteBandPoint4, whiteBandPoint1], 0.1, "#fffff");
			
			let bandLinePoint1 = [whiteBandPoint1[0], whiteBandPoint1[1], whiteBandPoint1[2] + 0.1/2];
			let bandLinePoint2 = [whiteBandPoint2[0], whiteBandPoint2[1], whiteBandPoint2[2] + 0.1/2];
			let bandLinePoint3 = [whiteBandPoint3[0], whiteBandPoint3[1], whiteBandPoint3[2] + 0.1/2];
			let bandLinePoint4= [whiteBandPoint4[0], whiteBandPoint4[1], whiteBandPoint4[2] + 0.1/2];
			drawLine([bandLinePoint1, bandLinePoint2, bandLinePoint3, bandLinePoint4, bandLinePoint1], 0.03, 0.03, '#fffff');
			
			if (!isLastCol) {
				// v·∫Ω c√°c v√≤m tr√™n c·ªôt
				let pts1 = drawColumnHeader(columnPoint2, circleStartPoint, circleFloorDistance);
				let pts2 = drawColumnHeader(columnPoint3, circleEndPoint, circleFloorDistance);
				for (let j = 0; j < pts1.length - 1; j ++) {
					let z = pts1[0][2] + columnWidthAsMetter + R;
					drawPolygon3D([pts1[j], pts1[j + 1], pts2[j + 1], pts2[j], pts1[j]], mainCorlor);
					let top1 = [pts1[j][0], pts1[j][1], z];
					
					let top2 = [pts1[j+ 1][0], pts1[j+ 1][1], z];
					drawPolygon3D([pts1[j], pts1[j + 1], top2, top1, pts1[j]], mainCorlor);
					
					let top3 = [pts2[j][0], pts2[j][1], z];
					
					let top4 = [pts2[j+1][0], pts2[j+1][1], z];
					drawPolygon3D([pts2[j], pts2[j + 1], top4, top3, pts2[j]], mainCorlor);
					drawPolygon3D([top1, top2, top4, top3,top1], mainCorlor);
				}
			}
			return [columnPoint1, columnPoint2, columnPoint3, columnPoint4, columnPoint1];
		}
		
		function drawLine(path, width, height, color) {
			// Polyline 3D (c√≥ Z)
			const pipeLine = new Polyline({
				spatialReference: { wkid: 4326 },
				hasZ: true,
				paths: [
					path
				]
			});

			// Symbol d·∫°ng ·ªêNG (tube)
			const pipeSymbol = {
				type: "line-3d",
				symbolLayers: [{
					type: "path",
					profile: "circle",     // üëà h√¨nh tr√≤n ‚Üí ·ªëng
					width: width,              // üëà ƒë∆∞·ªùng k√≠nh (m)
					height: height,
					material: {
						color: color
					},
					cap: "round",
					join: "round"
				}]
			};

			// Graphic
			const pipeGraphic = new Graphic({
				geometry: pipeLine,
				symbol: pipeSymbol,
				elevationInfo: {
					mode: "absolute-height" // Z l√† cao ƒë·ªô tuy·ªát ƒë·ªëi
				}
			});
			layer.add(pipeGraphic);
		}
		function drawPoint(p, name, corlor) {
			const point = new Point({
				x: p[0],
				y: p[1],
				z: p[2],
				spatialReference: { wkid: 4326 }
			});

			const graphic = new Graphic({
				geometry: point,
				symbol: {
				  type: "point-3d",
				  symbolLayers: [{
					type: "object",
					resource: { primitive: "sphere" },  // üîµ bi·ªÉu di·ªÖn d·∫°ng h√¨nh c·∫ßu 3D
					width: 0.08,
					height: 0.08,
					depth: 0.08,
					material: { color: corlor }
				  }]
				},
				popupTemplate: {
				  title: "ƒêi·ªÉm " + name,
				  content: `x: ${p[0]}<br>y: ${p[1]}<br>z: ${p[2]}`
				}
			});

			layer.add(graphic);
		};
		function drawWhiteBand() {
			
		}
		function calColumnDistance (floorWidth, colWidth, colNum) {
			return (floorWidth - colWidth*4 -colWidth*(colNum - 2))/(colNum-1);
		}
	    function norm(v) {
			const l = Math.hypot(v[0], v[1], v[2]);
			return [v[0]/l, v[1]/l, v[2]/l];
		}
		function angleOf(p, O, planeX, planeY) {
			const v = sub(p, O);
			// chi·∫øu l√™n 2 tr·ª•c
			const x = dot(v, planeX);
			const y = dot(v, planeY);
			return Math.atan2(y, x);
		}
		function distanceToMetter(A, B) {
			let line = new Polyline({
			  spatialReference: view.spatialReference,
			  paths: [
				[
				  [A[0],A[1]],   // x1, y1
				  [B[0], B[1]]    // x2, y2
				]
			  ]
			});
			return geometryEngine.geodesicLength(line, "meters");
		}

		function drawColumnHeader(A, B, height) {
			let R = distance3D(A, B)/2;// kho·∫£ng c√°ch t·ªça ƒë·ªô
			let RZ = distanceToMetter(A, B)/2;// kho·∫£ng c√°ch met
			let O = pointAtDistance(A, B, R, 0);// t√¢m c·ªßa ƒë∆∞·ªùng tr√≤n
			
			let pts = [];
			pts.push([A[0], A[1], A[2] + height]);
			for (let i = 1; i <= 15; i++) {
				let AX = (R/15)*i;
				let X = pointAtDistance(A, O, AX, 0);
				let XO = distanceToMetter(X, O);
				let XY = Math.sqrt(RZ*RZ -XO*XO);
				let Y = [X[0], X[1], X[2] + XY + height];
				pts.push(Y);
			}
			for (let i = 1; i < 15; i++) {
				let OX = (R/15)*i;
				let X = pointAtDistance(O, B, OX, 0);
				let OXm = distanceToMetter(O, X);
				let XY = Math.sqrt(RZ*RZ -OXm*OXm);
				let Y = [X[0], X[1], X[2] + XY + height];
				pts.push(Y);
			}
			pts.push([B[0], B[1], B[2] + height]);
			return pts;
		}
        /***************************************
         * 1Ô∏è‚É£ V·∫º NH√Ä 3 T·∫¶NG
         ****************************************/

        function addExtrudedBox(rings, height, color, isEdge) {
          layer.add(new Graphic({
		  geometry: new Polygon({ rings }),
		  symbol: new PolygonSymbol3D({
			symbolLayers: [
			  new ExtrudeSymbol3DLayer({
				size: height,
				material: { color: color },

				// üëá VI·ªÄN 3D
				edges: isEdge ? {
				  type: "solid",       // solid | sketch
				  color: [80, 80, 80, 0.8],      // m√†u vi·ªÅn
				  size: 1              // ƒë·ªô d√†y vi·ªÅn (px)
				} : {}
			  })
			]
		  })
		}));
        }
		
		function addDoorToThePosition(P, rotate) {
			let doorPostion = new Point({
                x: P[0],
                y: P[1],
                z: P[2],
            });
		
			Mesh.createFromGLTF(doorPostion, "./_door._old._wood2.glb")
				.then(function (geometry) {
					geometry.scale(0.011, { origin: doorPostion })
					geometry.rotate(0, 0, rotate);
					// L·∫•y extent
					const ext = geometry.extent;

					const width  = ext.xmax - ext.xmin;
					const depth  = ext.ymax - ext.ymin;
					const height = ext.zmax - ext.zmin;
					
					const graphic = new Graphic({
						geometry,
						symbol: {
							type: "mesh-3d",
							symbolLayers: [{
								type: "fill",
								size: 10
							}]
						}
					});
					layer.add(graphic)
				})
				.catch(console.error);
		}
		
				// T√≠nh t·ªça ƒë·ªô ƒëi·ªÉm C, bi·∫øt kho·∫£ng c√°ch PC, PC vu√¥ng g√≥c v·ªõi AP, C n·∫±m c√πng h∆∞·ªõng v·ªõi B
		function findC(A, P, B, x) {
			const u = sub(P, A);   // AP
			const v = sub(B, A);   // AB

			const n = cross(u, v); // ph√°p tuy·∫øn m·∫∑t ph·∫≥ng ABP
			const w = cross(n, u); // vector vu√¥ng g√≥c AP, n·∫±m trong m·∫∑t ph·∫≥ng

			let w_norm = normalize(w);

			// Ki·ªÉm tra h∆∞·ªõng: C ph·∫£i c√πng ph√≠a v·ªõi B
			if (dot(v, w_norm) < 0) {
				w_norm = scale(w_norm, -1);
			}

			// C = P + x * h∆∞·ªõng
			return add(P, scale(w_norm, x));
		}

		function drawDoor(startPoint, endPoint, C, heigh, width, doorHandledirection) {
			let length = distance3D(startPoint, endPoint);
			let colLength = length/6;
			let startTopPoint = [startPoint[0], startPoint[1], startPoint[2] + heigh];
			let endTopPoint = [endPoint[0], endPoint[1], endPoint[2] + heigh];
			
			let endPointIn = findC(startPoint, endPoint, C, width);
			let startPointIn = findC(endPoint, startPoint, C, width);
			
			let startPoint1 = pointAtDistance(startPoint, endPoint, colLength, 0);
			let endPoint1 = pointAtDistance(endPoint, startPoint, colLength, 0);
			let lengthMetter = distanceToMetter(startPoint, startPoint1);
			
			let endPointIn1 = findC(startPoint1, endPoint1, C, width);
			let startPointIn1 = findC(endPoint1, startPoint1, C, width);
			
			let doorCol1 = [startPoint, startPoint1, startPointIn1, startPointIn, startPoint];
			
			let doorCol2 = [endPoint1, endPoint, endPointIn, endPointIn1, endPoint1];
			addExtrudedBox(doorCol1, heigh, mainCorlor, true);
			addExtrudedBox(doorCol2, heigh, mainCorlor, true);
			
			let bar1Point1 = startPoint1;
			let bar1Point2 = endPoint1;
			let bar1Point3 = endPointIn1;
			let bar1Point4 = startPointIn1;
			let bar1 = [bar1Point1, bar1Point2, bar1Point3, bar1Point4, bar1Point1];
			
			addExtrudedBox(bar1, lengthMetter, mainCorlor, true);
			
			
			let board1Point1 = findC(endPoint1, startPoint1, C, width/2);
			let board1Point2 = findC(startPoint1, endPoint1, C, width/2);
			board1Point1[2] += lengthMetter;
			board1Point2[2] += lengthMetter;
			
			let boardHeight = (heigh - 3*lengthMetter)/2;
			let board1Point3 = [board1Point2[0], board1Point2[1], board1Point2[2] + boardHeight];
			let board1Point4 = [board1Point1[0], board1Point1[1], board1Point1[2] + boardHeight];
			
			let board1 = [board1Point1, board1Point2, board1Point3, board1Point4, board1Point1];
			drawPolygon3D(board1, mainCorlor);
			
			let bar2Point1 = [bar1Point1[0], bar1Point1[1], bar1Point1[2] + lengthMetter + boardHeight];
			let bar2Point2 = [bar1Point2[0], bar1Point2[1], bar1Point2[2] + lengthMetter + boardHeight];
			let bar2Point3 = [bar1Point3[0], bar1Point3[1], bar1Point3[2] + lengthMetter + boardHeight];
			let bar2Point4 = [bar1Point4[0], bar1Point4[1], bar1Point4[2] + lengthMetter + boardHeight];
			let bar2 = [bar2Point1, bar2Point2, bar2Point3, bar2Point4, bar2Point1];
			addExtrudedBox(bar2, lengthMetter, mainCorlor, true);
			
			let bar3Point1 = [bar2Point1[0], bar2Point1[1], bar2Point1[2] + lengthMetter + boardHeight];
			let bar3Point2 = [bar2Point2[0], bar2Point2[1], bar2Point2[2] + lengthMetter + boardHeight];
			let bar3Point3 = [bar2Point3[0], bar2Point3[1], bar2Point3[2] + lengthMetter + boardHeight];
			let bar3Point4 = [bar2Point4[0], bar2Point4[1], bar2Point4[2] + lengthMetter + boardHeight];
			let bar3 = [bar3Point1, bar3Point2, bar3Point3, bar3Point4, bar3Point1];
			addExtrudedBox(bar3, lengthMetter, mainCorlor, true);
			
			
			let board2Point1 = [board1Point1[0], board1Point1[1], board1Point1[2] + lengthMetter + boardHeight];
			let board2Point2 = [board1Point2[0], board1Point2[1], board1Point2[2] + lengthMetter + boardHeight];
			let board2Point3 = [board1Point3[0], board1Point3[1], board1Point3[2] + lengthMetter + boardHeight];
			let board2Point4 = [board1Point4[0], board1Point4[1], board1Point4[2] + lengthMetter + boardHeight];
			let board2 = [board2Point1, board2Point2, board2Point3, board2Point4, board2Point1];
			drawPolygon3D(board2, mainCorlor);
			
			let doorHandleCenterPoint;
			let doorHandleStartPoint;
			if (doorHandledirection == startPoint) {
				let tempPoint = pointAtDistance(startPoint, endPoint, colLength/2, 0);
				doorHandleCenterPoint = findC(startPoint, tempPoint, startPointIn, width/2);
				doorHandleStartPoint = findC(startPoint, tempPoint, startPointIn, width + colLength/2);
			} else {
				let tempPoint = pointAtDistance(endPoint, startPoint, colLength/2, 0);
				doorHandleCenterPoint = findC(endPoint, tempPoint, endPointIn, width/2);
				doorHandleStartPoint = findC(endPoint, tempPoint, endPointIn, width + colLength/2);
			}
			let doorHandleEndPoint = pointAtDistance(doorHandleStartPoint, doorHandleCenterPoint, colLength + width, 0);
			
			doorHandleStartPoint[2] += heigh/2;
			doorHandleEndPoint[2] += heigh/2;
			drawPoint(doorHandleStartPoint, 'doorHandleStartPoint', "#f2e6d9");
			drawPoint(doorHandleEndPoint, 'doorHandleEndPoint', "#f2e6d9");
			drawLine([doorHandleStartPoint, doorHandleEndPoint], 0.03, 0.03, "#f2e6d9");
		}
		
		function drawVentilation(startPoint, endPoint, C, heigh, width) {
			let length = distance3D(startPoint, endPoint);
			let colLength = length/12;
			let startTopPoint = [startPoint[0], startPoint[1], startPoint[2] + heigh];
			let endTopPoint = [endPoint[0], endPoint[1], endPoint[2] + heigh];
			
			let endPointIn = findC(startPoint, endPoint, C, width);
			let startPointIn = findC(endPoint, startPoint, C, width);
			
			let startPoint1 = pointAtDistance(startPoint, endPoint, colLength, 0);
			let endPoint1 = pointAtDistance(endPoint, startPoint, colLength, 0);
			let lengthMetter = distanceToMetter(startPoint, startPoint1);
			
			let endPointIn1 = findC(startPoint1, endPoint1, C, width);
			let startPointIn1 = findC(endPoint1, startPoint1, C, width);
			
			let doorCol1 = [startPoint, startPoint1, startPointIn1, startPointIn, startPoint];
			
			let doorCol2 = [endPoint1, endPoint, endPointIn, endPointIn1, endPoint1];
			addExtrudedBox(doorCol1, heigh, mainCorlor, true);
			addExtrudedBox(doorCol2, heigh, mainCorlor, true);
			
			let bar1Point1 = startPoint1;
			let bar1Point2 = endPoint1;
			let bar1Point3 = endPointIn1;
			let bar1Point4 = startPointIn1;
			let bar1 = [bar1Point1, bar1Point2, bar1Point3, bar1Point4, bar1Point1];
			
			addExtrudedBox(bar1, lengthMetter*1.5, mainCorlor, true);
			
			let boardHeight = (heigh - 2*lengthMetter*1.5);
			
			let bar2Point1 = [bar1Point1[0], bar1Point1[1], bar1Point1[2] + lengthMetter*1.5 + boardHeight];
			let bar2Point2 = [bar1Point2[0], bar1Point2[1], bar1Point2[2] + lengthMetter*1.5 + boardHeight];
			let bar2Point3 = [bar1Point3[0], bar1Point3[1], bar1Point3[2] + lengthMetter*1.5 + boardHeight];
			let bar2Point4 = [bar1Point4[0], bar1Point4[1], bar1Point4[2] + lengthMetter*1.5 + boardHeight];
			let bar2 = [bar2Point1, bar2Point2, bar2Point3, bar2Point4, bar2Point1];
			addExtrudedBox(bar2, lengthMetter*1.5, mainCorlor, true);
			
			let ventilationSlotDistance = boardHeight/24;
			for (let i = 0; i < 12; i++) {
				let ventilationSlotPoint1 = [bar1Point1[0], bar1Point1[1], bar1Point1[2] + ventilationSlotDistance*i*2 + lengthMetter*1.5];
				let ventilationSlotPoint2 = [bar1Point2[0], bar1Point2[1], bar1Point2[2] + ventilationSlotDistance*i*2 + lengthMetter*1.5];
				let ventilationSlotPoint3 = [bar1Point3[0], bar1Point3[1], bar1Point3[2] + ventilationSlotDistance*(i*2 + 1.8) + lengthMetter*1.5];
				let ventilationSlotPoint4 = [bar1Point4[0], bar1Point4[1], bar1Point4[2] + ventilationSlotDistance*(i*2 + 1.8) + lengthMetter*1.5];
				let ventilationSlotPoints = [ventilationSlotPoint1, ventilationSlotPoint2, ventilationSlotPoint3, ventilationSlotPoint4, ventilationSlotPoint1];
				drawPolygon3D(ventilationSlotPoints, mainCorlor);
			}
		}

		function drawfloor(floor, floorHeigh, colHeight) {
			let floorPoint1 = floor[0];
			let floorPoint2 = floor[1];
			let floorPoint3 = floor[2];
			let floorPoint4 = floor[3];
			addExtrudedBox(floor, floorHeigh, "#f2e6d9");
			
			let floorWidth = distance3D(floorPoint1, floorPoint2);
			let colNum = 8;
			const colZ = floorPoint1[2] + floorHeigh;
			
			
			let colWidth = floorWidth/((colNum-1)*6);
			let colmDistance = calColumnDistance(floorWidth, colWidth, colNum);
			let colmDistance1 = colmDistance;
			for (let i = 0; i < colNum; i++) {
				let width = colWidth;
				
				if (i == colNum - 1) {
					addExtrudedBox(drawColumn(floorPoint2, floorPoint1, floorPoint3, colWidth, colmDistance, 0, floorHeigh, true), colHeight, mainCorlor);
				} else {
					addExtrudedBox(drawColumn(floorPoint1, floorPoint2, floorPoint4, colWidth, colmDistance, i, floorHeigh, false), colHeight, mainCorlor);
				}
			}
			
			floorWidth = distance3D(floorPoint3, floorPoint4);
			colmDistance = calColumnDistance(floorWidth, colWidth, colNum);
			let colmDistance2 = colmDistance;
			for (let i = 0; i < colNum; i++) {
				let width = colWidth;
				
				if (i == colNum - 1) {
					addExtrudedBox(drawColumn(floorPoint4, floorPoint3, floorPoint1, colWidth, colmDistance, 0, floorHeigh, true), colHeight, mainCorlor);
				} else {
					addExtrudedBox(drawColumn(floorPoint3, floorPoint4, floorPoint2, colWidth, colmDistance, i, floorHeigh, false), colHeight, mainCorlor);
				}
			}
			floorWidth = distance3D(floorPoint2, floorPoint3);
			colNum = 10;
			colmDistance = calColumnDistance(floorWidth, colWidth, colNum);
			let colmDistance3 = colmDistance;
			for (let i = 0; i < colNum; i++) {
				let width = colWidth;
				
				if (i == colNum - 1) {
					addExtrudedBox(drawColumn(floorPoint3, floorPoint2, floorPoint4, colWidth, colmDistance, 0, floorHeigh, true), colHeight, mainCorlor);
				} else {
					addExtrudedBox(drawColumn(floorPoint2, floorPoint3, floorPoint1, colWidth, colmDistance, i, floorHeigh, false), colHeight, mainCorlor);
				}
			}
			floorWidth = distance3D(floorPoint4, floorPoint1);
			colmDistance = calColumnDistance(floorWidth, colWidth, colNum);
			let colmDistance4 = colmDistance;
			for (let i = 0; i < colNum; i++) {
				let width = colWidth;
				
				if (i == colNum - 1) {
					addExtrudedBox(drawColumn(floorPoint1, floorPoint4, floorPoint2, colWidth, colmDistance, 0, floorHeigh, true), colHeight, mainCorlor);
				} else {
					addExtrudedBox(drawColumn(floorPoint4, floorPoint1, floorPoint3, colWidth, colmDistance, i, floorHeigh, false), colHeight, mainCorlor);
				}
			}
			
			// v·∫Ω ph√≤ng l·ªõn
			let romPoint1Mapping = pointAtDistance(floorPoint1, floorPoint2, colmDistance1 + colWidth*2, 0);
			let romPoint1 = findC(floorPoint1, romPoint1Mapping, floorPoint4, colmDistance4 +colWidth*2);
			let romPoint2Mapping = pointAtDistance(floorPoint2, floorPoint1, colmDistance1 + colWidth*2, 0);
			let romPoint2 = findC(floorPoint2, romPoint2Mapping, floorPoint3, colmDistance2 +colWidth*2);
			
			let romPoint3Mapping = pointAtDistance(floorPoint3, floorPoint4, colmDistance3 + colWidth*2, 0);
			let romPoint3 = findC(floorPoint3, romPoint3Mapping, floorPoint2, colmDistance2 +colWidth*2);
			let romPoint4Mapping = pointAtDistance(floorPoint4, floorPoint3, colmDistance3 + colWidth*2, 0);
			let romPoint4 = findC(floorPoint4, romPoint4Mapping, floorPoint1, colmDistance4 +colWidth*2);
			
			romPoint1[2] = romPoint1[2] + floorHeigh;
			romPoint2[2] = romPoint2[2] + floorHeigh;
			romPoint3[2] = romPoint3[2] + floorHeigh;
			romPoint4[2] = romPoint4[2] + floorHeigh;
			drawPoint(romPoint1, "romPoint1", "#f2e6d9");
			drawPoint(romPoint2, "romPoint2", "#f2e6d9");
			drawPoint(romPoint3, "romPoint3", "#f2e6d9");
			drawPoint(romPoint4, "romPoint4", "#f2e6d9");
			

			let doorNum = 5;
			let doorWidth = colWidth/8;
			let doorHeight = 3.5;
			let wall1Length = distance3D(romPoint1Mapping, romPoint2Mapping);
			let doorDistance = (wall1Length)/(doorNum);
			
			for (let j = 0; j < doorNum; j++) {
				let startPoint = pointAtDistance(romPoint1, romPoint2, doorDistance*j + doorDistance/3, 0);
				let middlePoint = pointAtDistance(startPoint, romPoint2, doorDistance/6, 0);
				let endPoint = pointAtDistance(startPoint, romPoint2, doorDistance/3, 0);
				
				drawDoor(startPoint, middlePoint, romPoint3, doorHeight, doorWidth);
				drawDoor(middlePoint, endPoint, romPoint3, doorHeight, doorWidth, middlePoint);
				startPoint[2] += doorHeight;
				endPoint[2] += doorHeight;
				let C = [romPoint3[0], romPoint3[1], romPoint3[2] + doorHeight];
				drawVentilation(startPoint, endPoint, C, doorHeight/5, doorWidth);
				
				startPoint[2] -= doorHeight;
				let wallSub1Point1 = pointAtDistance(romPoint1, romPoint2, doorDistance*j, 0);
				let wallSub1Point2 = startPoint;
				let wallSub1Point3= findC(wallSub1Point1, wallSub1Point2, romPoint3, colWidth/4, 0);
				let wallSub1Point4= findC(wallSub1Point2, wallSub1Point1, romPoint3, colWidth/4, 0);
				let wallSub1 = [wallSub1Point1, wallSub1Point2, wallSub1Point3, wallSub1Point4, wallSub1Point1];
				addExtrudedBox(wallSub1, doorHeight + doorHeight/5, mainCorlor);
				endPoint[2] -= doorHeight;
				let wallSub2Point1 = endPoint;
				let wallSub2Point2 = pointAtDistance(romPoint1, romPoint2, doorDistance*(j + 1), 0);;
				let wallSub2Point3= findC(wallSub2Point1, wallSub2Point2, romPoint3, colWidth/4, 0);
				let wallSub2Point4= findC(wallSub2Point2, wallSub2Point1, romPoint3, colWidth/4, 0);
				let wallSub2 = [wallSub2Point1, wallSub2Point2, wallSub2Point3, wallSub2Point4, wallSub2Point1];
				addExtrudedBox(wallSub2, doorHeight + doorHeight/5, mainCorlor);
				
				wallSub1Point1[2] += doorHeight + doorHeight/5;
				wallSub1Point4[2] += doorHeight + doorHeight/5;
				wallSub2Point3[2] += doorHeight + doorHeight/5;
				wallSub2Point2[2] += doorHeight + doorHeight/5;
				let wallTop = [wallSub1Point1, wallSub2Point2, wallSub2Point3, wallSub1Point4, wallSub1Point1]
				addExtrudedBox(wallTop, colHeight - (doorHeight + doorHeight/5), mainCorlor);
			}
			let wall3Length = distance3D(romPoint3, romPoint4);
			doorDistance = (wall3Length)/(doorNum);
			for (let j = 0; j < doorNum; j++) {
				let startPoint = pointAtDistance(romPoint3, romPoint4, doorDistance*j + doorDistance/3, 0);
				let middlePoint = pointAtDistance(startPoint, romPoint4, doorDistance/6, 0);
				let endPoint = pointAtDistance(startPoint, romPoint4, doorDistance/3, 0);
				
				drawDoor(startPoint, middlePoint, romPoint1, doorHeight, doorWidth);
				drawDoor(middlePoint, endPoint, romPoint1, doorHeight, doorWidth, middlePoint);
				startPoint[2] += doorHeight;
				endPoint[2] += doorHeight;
				let C = [romPoint1[0], romPoint1[1], romPoint1[2] + doorHeight];
				drawVentilation(startPoint, endPoint, C, doorHeight/5, doorWidth);
				
				startPoint[2] -= doorHeight;
				let wallSub1Point1 = pointAtDistance(romPoint3, romPoint4, doorDistance*j, 0);
				let wallSub1Point2 = startPoint;
				let wallSub1Point3= findC(wallSub1Point1, wallSub1Point2, romPoint1, colWidth/4, 0);
				let wallSub1Point4= findC(wallSub1Point2, wallSub1Point1, romPoint1, colWidth/4, 0);
				let wallSub1 = [wallSub1Point1, wallSub1Point2, wallSub1Point3, wallSub1Point4, wallSub1Point1];
				addExtrudedBox(wallSub1, doorHeight + doorHeight/5, mainCorlor);
				endPoint[2] -= doorHeight;
				let wallSub2Point1 = endPoint;
				let wallSub2Point2 = pointAtDistance(romPoint3, romPoint4, doorDistance*(j + 1), 0);;
				let wallSub2Point3= findC(wallSub2Point1, wallSub2Point2, romPoint1, colWidth/4, 0);
				let wallSub2Point4= findC(wallSub2Point2, wallSub2Point1, romPoint1, colWidth/4, 0);
				let wallSub2 = [wallSub2Point1, wallSub2Point2, wallSub2Point3, wallSub2Point4, wallSub2Point1];
				addExtrudedBox(wallSub2, doorHeight + doorHeight/5, mainCorlor);
				
				wallSub1Point1[2] += doorHeight + doorHeight/5;
				wallSub1Point4[2] += doorHeight + doorHeight/5;
				wallSub2Point3[2] += doorHeight + doorHeight/5;
				wallSub2Point2[2] += doorHeight + doorHeight/5;
				let wallTop = [wallSub1Point1, wallSub2Point2, wallSub2Point3, wallSub1Point4, wallSub1Point1]
				addExtrudedBox(wallTop, colHeight - (doorHeight + doorHeight/5), mainCorlor);
				
			}

			let wall2Length = distance3D(romPoint2, romPoint3);
			doorNum = 7;
			wall1Length = distance3D(romPoint2Mapping, romPoint3Mapping);
			doorDistance = (wall2Length)/(doorNum);
			
			for (let j = 0; j < doorNum; j++) {
				let startPoint = pointAtDistance(romPoint2, romPoint3, doorDistance*j + doorDistance/3, 0);
				let middlePoint = pointAtDistance(startPoint, romPoint3, doorDistance/6, 0);
				let endPoint = pointAtDistance(startPoint, romPoint3, doorDistance/3, 0);
				
				drawDoor(startPoint, middlePoint, romPoint4, doorHeight, doorWidth);
				drawDoor(middlePoint, endPoint, romPoint4, doorHeight, doorWidth, middlePoint);
				startPoint[2] += doorHeight;
				endPoint[2] += doorHeight;
				let C = [romPoint4[0], romPoint4[1], romPoint4[2] + doorHeight];
				drawVentilation(startPoint, endPoint, C, doorHeight/5, doorWidth);
				
				startPoint[2] -= doorHeight;
				let wallSub1Point1 = pointAtDistance(romPoint2, romPoint3, doorDistance*j, 0);
				let wallSub1Point2 = startPoint;
				let wallSub1Point3= findC(wallSub1Point1, wallSub1Point2, romPoint4, colWidth/4, 0);
				let wallSub1Point4= findC(wallSub1Point2, wallSub1Point1, romPoint4, colWidth/4, 0);
				let wallSub1 = [wallSub1Point1, wallSub1Point2, wallSub1Point3, wallSub1Point4, wallSub1Point1];
				addExtrudedBox(wallSub1, doorHeight + doorHeight/5, mainCorlor);
				endPoint[2] -= doorHeight;
				let wallSub2Point1 = endPoint;
				let wallSub2Point2 = pointAtDistance(romPoint2, romPoint3, doorDistance*(j + 1), 0);;
				let wallSub2Point3= findC(wallSub2Point1, wallSub2Point2, romPoint4, colWidth/4, 0);
				let wallSub2Point4= findC(wallSub2Point2, wallSub2Point1, romPoint4, colWidth/4, 0);
				let wallSub2 = [wallSub2Point1, wallSub2Point2, wallSub2Point3, wallSub2Point4, wallSub2Point1];
				addExtrudedBox(wallSub2, doorHeight + doorHeight/5, mainCorlor);
				
				wallSub1Point1[2] += doorHeight + doorHeight/5;
				wallSub1Point4[2] += doorHeight + doorHeight/5;
				wallSub2Point3[2] += doorHeight + doorHeight/5;
				wallSub2Point2[2] += doorHeight + doorHeight/5;
				let wallTop = [wallSub1Point1, wallSub2Point2, wallSub2Point3, wallSub1Point4, wallSub1Point1]
				addExtrudedBox(wallTop, colHeight - (doorHeight + doorHeight/5), mainCorlor);
				
			}
			let wall4Length = distance3D(romPoint4, romPoint1);
			wall1Length = distance3D(romPoint4Mapping, romPoint1Mapping);
			doorDistance = (wall4Length)/(doorNum)
			for (let j = 0; j < doorNum; j++) {
				let startPoint = pointAtDistance(romPoint4, romPoint1, doorDistance*j + doorDistance/3, 0);
				let middlePoint = pointAtDistance(startPoint, romPoint1, doorDistance/6, 0);
				let endPoint = pointAtDistance(startPoint, romPoint1, doorDistance/3, 0);
				
				drawDoor(startPoint, middlePoint, romPoint2, doorHeight, doorWidth);
				drawDoor(middlePoint, endPoint, romPoint2, doorHeight, doorWidth, middlePoint);
				startPoint[2] += doorHeight;
				endPoint[2] += doorHeight;
				let C = [romPoint3[0], romPoint3[1], romPoint3[2] + doorHeight];
				drawVentilation(startPoint, endPoint, C, doorHeight/5, doorWidth);
				
				startPoint[2] -= doorHeight;
				let wallSub1Point1 = pointAtDistance(romPoint4, romPoint1, doorDistance*j, 0);
				let wallSub1Point2 = startPoint;
				let wallSub1Point3= findC(wallSub1Point1, wallSub1Point2, romPoint2, colWidth/4, 0);
				let wallSub1Point4= findC(wallSub1Point2, wallSub1Point1, romPoint2, colWidth/4, 0);
				let wallSub1 = [wallSub1Point1, wallSub1Point2, wallSub1Point3, wallSub1Point4, wallSub1Point1];
				addExtrudedBox(wallSub1, doorHeight + doorHeight/5, mainCorlor);
				endPoint[2] -= doorHeight;
				let wallSub2Point1 = endPoint;
				let wallSub2Point2 = pointAtDistance(romPoint4, romPoint1, doorDistance*(j + 1), 0);;
				let wallSub2Point3= findC(wallSub2Point1, wallSub2Point2, romPoint2, colWidth/4, 0);
				let wallSub2Point4= findC(wallSub2Point2, wallSub2Point1, romPoint2, colWidth/4, 0);
				let wallSub2 = [wallSub2Point1, wallSub2Point2, wallSub2Point3, wallSub2Point4, wallSub2Point1];
				addExtrudedBox(wallSub2, doorHeight + doorHeight/5, mainCorlor);
				
				wallSub1Point1[2] += doorHeight + doorHeight/5;
				wallSub1Point4[2] += doorHeight + doorHeight/5;
				wallSub2Point3[2] += doorHeight + doorHeight/5;
				wallSub2Point2[2] += doorHeight + doorHeight/5;
				let wallTop = [wallSub1Point1, wallSub2Point2, wallSub2Point3, wallSub1Point4, wallSub1Point1]
				addExtrudedBox(wallTop, colHeight - (doorHeight + doorHeight/5), mainCorlor);
			}
		}
		
		const floor1Height = 1.5;
		const floor1Z = 2;
		const colHeight1 = 5;
		const floor1FirstPointX = 106.7069257;
		const floor1FirtPointY = 10.768433;
		const floor1FirstPoint = [floor1FirstPointX, floor1FirtPointY, floor1Z]// kinh ƒë·ªô, vƒ© ƒë·ªô, ƒë·ªô cao
		
		const floor1SecondPointX = 106.70703;
		const floor1SecondPointY = 10.768215;
		const floor1SecondPoint = [floor1SecondPointX, floor1SecondPointY, floor1Z];
		
		const floor1ThirdPointX = 106.7067549;
		const floor1ThirdPointY = 10.76808798;
		const floor1ThirdPoint = [floor1ThirdPointX, floor1ThirdPointY, floor1Z];
		
		const floor1LastPointX = 106.7066515;
		const floor1LastPointY = 10.768303;
		const floor1LastPoint = [floor1LastPointX, floor1LastPointY, floor1Z];
		
        // T·∫ßng 1
        const floor1 = [
            floor1FirstPoint,
            floor1SecondPoint,
            floor1ThirdPoint,
            floor1LastPoint,
            floor1FirstPoint
        ];
        drawfloor(floor1, floor1Height, colHeight1);

        // T·∫ßng 2 (nh·ªè h∆°n)
		let floor2Height = floor1Height/4;
		const colHeight2 = 5;
		let floor2FirstPoint = [floor1FirstPoint[0], floor1FirstPoint[1], floor1FirstPoint[2] + floor1Height + colHeight1];
		let floor2SecondPoint = [floor1SecondPoint[0], floor1SecondPoint[1], floor1SecondPoint[2] + floor1Height + colHeight1];
		let floor2ThirdPoint = [floor1ThirdPoint[0], floor1ThirdPoint[1], floor1ThirdPoint[2] + floor1Height + colHeight1];
		let floor2LastPoint = [floor1LastPoint[0], floor1LastPoint[1], floor1LastPoint[2] + floor1Height + colHeight1];
        const floor2 = [
            floor2FirstPoint,
            floor2SecondPoint,
            floor2ThirdPoint,
            floor2LastPoint,
            floor2FirstPoint
        ];

		drawfloor(floor2, floor2Height, colHeight2);
		
		
		let floor3Height = floor2Height;
		const colHeight3 = 5;
		let floor3FirstPoint = [floor2FirstPoint[0], floor2FirstPoint[1], floor2FirstPoint[2] + floor2Height + colHeight2];
		let floor3SecondPoint = [floor2SecondPoint[0], floor2SecondPoint[1], floor2SecondPoint[2] + floor2Height + colHeight2];
		let floor3ThirdPoint = [floor2ThirdPoint[0], floor2ThirdPoint[1], floor2ThirdPoint[2] + floor2Height + colHeight2];
		let floor3LastPoint = [floor2LastPoint[0], floor2LastPoint[1], floor2LastPoint[2] + floor2Height + colHeight2];
        const floor3 = [
            floor3FirstPoint,
            floor3SecondPoint,
            floor3ThirdPoint,
            floor3LastPoint,
            floor3FirstPoint
        ];
		
		drawfloor(floor3, floor3Height, colHeight3);
      });
    </script>
  </head>
  <body>
    <div id="viewDiv"></div>
  </body>
</html>
